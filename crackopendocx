#!/usr/bin/env python3
"""
DOCX Embedded File Extractor

This script extracts all embedded files from DOCX documents, including:
- Files embedded as objects within DOCX files
- Recursive extraction from nested DOCX files
- Extraction of attachments from embedded .msg (Outlook email) files

Dependencies:
    pip install python-docx extract-msg zipfile36

Usage:
    python docx_extractor.py input_file.docx [output_directory]
"""

import os
import sys
import zipfile
import shutil
import tempfile
import argparse
import logging
from pathlib import Path
from typing import List, Set, Dict, Any
import mimetypes

try:
    import extract_msg
    MSG_AVAILABLE = True
except ImportError:
    MSG_AVAILABLE = False
    print("Warning: extract-msg not available. .msg file processing disabled.")

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class FileExtractor:
    def __init__(self, base_output_dir: str):
        self.base_output_dir = Path(base_output_dir)
        self.base_output_dir.mkdir(exist_ok=True)
        self.file_counter = 0
        self.processed_files: Set[str] = set()
        self.recursion_tree = []  # Store the extraction tree for display
        
    def get_next_filename(self, original_name: str, extension: str = None) -> str:
        """Generate the next sequential filename preserving original title"""
        self.file_counter += 1
        
        # Clean the original name to use as title (remove path and keep base name)
        clean_name = os.path.basename(original_name)
        
        # Remove extension from clean_name for the title part
        if '.' in clean_name:
            title_part = '.'.join(clean_name.split('.')[:-1])  # Everything except last extension
            original_ext = clean_name.split('.')[-1]
        else:
            title_part = clean_name
            original_ext = extension if extension else 'bin'
        
        # Use provided extension if available, otherwise use original
        final_ext = extension if extension else original_ext
        
        # Create filename with format: RL2-11_NNN_<original_title>.<ext>
        new_filename = f"RL2-11_{self.file_counter:03d}_{title_part}.{final_ext}"
        
        return new_filename
    
    def extract_embedded_files_from_docx(self, docx_path: str, current_level: int = 0) -> List[str]:
        """Extract embedded files from a DOCX file"""
        extracted_files = []
        indent = "  " * current_level
        
        logger.info(f"{indent}Processing DOCX: {docx_path}")
        
        try:
            # DOCX files are ZIP archives
            with zipfile.ZipFile(docx_path, 'r') as docx_zip:
                # Look for embedded objects in the embeddings folder
                embedding_files = []
                
                for file_info in docx_zip.filelist:
                    filename = file_info.filename
                    
                    # Check for embedded objects
                    if filename.startswith('word/embeddings/'):
                        embedding_files.append(filename)
                    
                    # Also check for media files that might be embedded objects
                    elif (filename.startswith('word/media/') and 
                          not filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.emf'))):
                        embedding_files.append(filename)
                
                logger.info(f"{indent}Found {len(embedding_files)} embedded files")
                
                # Extract each embedded file
                for embedded_file in embedding_files:
                    try:
                        # Extract the file data
                        file_data = docx_zip.read(embedded_file)
                        
                        # Determine file extension from content or filename
                        original_filename = os.path.basename(embedded_file)
                        
                        # Try to detect file type
                        file_extension = self.detect_file_type(file_data, original_filename)
                        
                        # Skip if it's an image file we don't want to process
                        if file_extension is None:
                            logger.info(f"{indent}Skipping image file: {original_filename}")
                            continue
                        
                        # Generate new filename
                        new_filename = self.get_next_filename(original_filename, file_extension)
                        output_path = self.base_output_dir / new_filename
                        
                        # Save the file
                        with open(output_path, 'wb') as f:
                            f.write(file_data)
                        
                        logger.info(f"{indent}Extracted: {new_filename} (original: {original_filename})")
                        extracted_files.append(str(output_path))
                        
                        # Add to recursion tree
                        tree_prefix = ">" * current_level
                        self.recursion_tree.append(f"{tree_prefix}{new_filename}")
                        
                        # Recursive processing
                        if file_extension == 'docx':
                            logger.info(f"{indent}Found nested DOCX, recursing...")
                            nested_files = self.extract_embedded_files_from_docx(str(output_path), current_level + 1)
                            extracted_files.extend(nested_files)
                        
                        elif file_extension == 'msg' and MSG_AVAILABLE:
                            logger.info(f"{indent}Found .msg file, processing...")
                            msg_files = self.extract_from_msg_file(str(output_path), current_level + 1)
                            extracted_files.extend(msg_files)
                            
                    except Exception as e:
                        logger.error(f"{indent}Error extracting {embedded_file}: {str(e)}")
                        continue
                        
        except Exception as e:
            logger.error(f"{indent}Error processing DOCX {docx_path}: {str(e)}")
            
        return extracted_files
    
    def extract_from_msg_file(self, msg_path: str, current_level: int = 0) -> List[str]:
        """Extract attachments from a .msg (Outlook email) file"""
        if not MSG_AVAILABLE:
            logger.warning("extract-msg not available, skipping .msg file processing")
            return []
            
        extracted_files = []
        indent = "  " * current_level
        
        logger.info(f"{indent}Processing MSG: {msg_path}")
        
        try:
            # Parse the .msg file
            msg = extract_msg.Message(msg_path)
            
            # Extract attachments
            attachments = msg.attachments
            logger.info(f"{indent}Found {len(attachments)} attachments in MSG file")
            
            for attachment in attachments:
                try:
                    # Get attachment data and filename
                    attachment_data = attachment.data
                    attachment_filename = attachment.longFilename or attachment.shortFilename or "unknown_attachment"
                    
                    # Generate new filename
                    file_extension = self.detect_file_type(attachment_data, attachment_filename)
                    
                    # Skip if it's an image file we don't want to process
                    if file_extension is None:
                        logger.info(f"{indent}Skipping image attachment: {attachment_filename}")
                        continue
                    new_filename = self.get_next_filename(attachment_filename, file_extension)
                    output_path = self.base_output_dir / new_filename
                    
                    # Save the attachment
                    with open(output_path, 'wb') as f:
                        f.write(attachment_data)
                    
                    logger.info(f"{indent}Extracted attachment: {new_filename} (original: {attachment_filename})")
                    extracted_files.append(str(output_path))
                    
                    # Add to recursion tree
                    tree_prefix = ">" * current_level
                    self.recursion_tree.append(f"{tree_prefix}{new_filename}")
                    
                    # Recursive processing for DOCX attachments
                    if file_extension == 'docx':
                        logger.info(f"{indent}Found DOCX attachment, recursing...")
                        nested_files = self.extract_embedded_files_from_docx(str(output_path), current_level + 1)
                        extracted_files.extend(nested_files)
                    
                    # Recursive processing for MSG attachments
                    elif file_extension == 'msg':
                        logger.info(f"{indent}Found nested MSG attachment, recursing...")
                        nested_msg_files = self.extract_from_msg_file(str(output_path), current_level + 1)
                        extracted_files.extend(nested_msg_files)
                        
                except Exception as e:
                    logger.error(f"{indent}Error extracting attachment: {str(e)}")
                    continue
                    
        except Exception as e:
            logger.error(f"{indent}Error processing MSG file {msg_path}: {str(e)}")
            
        return extracted_files
    
    def detect_file_type(self, file_data: bytes, filename: str) -> str:
        """Detect file type from content and filename"""
        
        # File signatures for detection (excluding image files we don't want)
        file_signatures = {
            b'\x50\x4B\x03\x04': 'zip',  # Generic ZIP (could be DOCX, XLSX, etc.)
            b'\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1': 'msg',  # OLE/MSG files
            b'\x50\x4B\x07\x08': 'zip',  # ZIP variant
            b'\x50\x4B\x05\x06': 'zip',  # ZIP variant
            b'%PDF': 'pdf',
            # Note: Removed image formats as we're ignoring them
        }
        
        # Check magic bytes
        for signature, file_type in file_signatures.items():
            if file_data.startswith(signature):
                # Special handling for ZIP-based formats
                if file_type == 'zip':
                    if filename.lower().endswith('.docx'):
                        return 'docx'
                    elif filename.lower().endswith('.xlsx'):
                        return 'xlsx'
                    elif filename.lower().endswith('.pptx'):
                        return 'pptx'
                return file_type
        
        # Check if it's an image file we want to ignore
        image_extensions = ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.emf', '.wmf', '.tiff', '.tif']
        if any(filename.lower().endswith(ext) for ext in image_extensions):
            return None  # Signal to ignore this file
        
        # Fall back to filename extension
        if '.' in filename:
            ext = filename.split('.')[-1].lower()
            # Don't process image files
            if f'.{ext}' in image_extensions:
                return None
            return ext
        
        # Try MIME type detection
        mime_type, _ = mimetypes.guess_type(filename)
        if mime_type:
            extension_map = {
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'xlsx',
                'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'pptx',
                'application/pdf': 'pdf',
                'application/vnd.ms-outlook': 'msg',
            }
            return extension_map.get(mime_type, 'bin')
        
        return 'bin'  # Unknown binary file

def main():
    parser = argparse.ArgumentParser(description='Extract embedded files from DOCX documents')
    parser.add_argument('input_file', help='Input DOCX file path')
    parser.add_argument('output_dir', nargs='?', default='extracted_files', 
                       help='Output directory (default: extracted_files)')
    parser.add_argument('-v', '--verbose', action='store_true', 
                       help='Enable verbose logging')
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Validate input file
    input_path = Path(args.input_file)
    if not input_path.exists():
        logger.error(f"Input file does not exist: {input_path}")
        sys.exit(1)
    
    if not input_path.suffix.lower() == '.docx':
        logger.error(f"Input file must be a .docx file: {input_path}")
        sys.exit(1)
    
    # Create extractor and process file
    extractor = FileExtractor(args.output_dir)
    
    try:
        logger.info(f"Starting extraction from: {input_path}")
        extracted_files = extractor.extract_embedded_files_from_docx(str(input_path))
        
        logger.info(f"Extraction complete. Total files extracted: {len(extracted_files)}")
        logger.info(f"Files saved to: {extractor.base_output_dir}")
        
        if extracted_files:
            print("\nExtracted files:")
            for i, file_path in enumerate(extracted_files, 1):
                print(f"  {i}. {Path(file_path).name}")
                
            print("\nRecursion Tree:")
            if extractor.recursion_tree:
                for tree_entry in extractor.recursion_tree:
                    print(tree_entry)
            else:
                print("No files extracted (no recursion tree to display)")
        else:
            print("No embedded files found.")
            
    except Exception as e:
        logger.error(f"Extraction failed: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()
