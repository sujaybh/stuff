#!/usr/bin/env python3
"""
DOCX Embedded File Extractor

This script extracts embedded files (OLE objects) from DOCX files and recursively
processes any embedded DOCX files found within them.

Requirements:
    pip install python-docx extract-msg

Usage:
    python docx_extractor.py input_file.docx [output_directory]
"""

import os
import sys
import zipfile
import shutil
from pathlib import Path
import argparse
from typing import List, Set
import mimetypes

# Try to import required libraries
try:
    from docx import Document
except ImportError:
    print("Error: python-docx library not found. Please install it with:")
    print("pip install python-docx")
    sys.exit(1)

try:
    import extract_msg
except ImportError:
    print("Error: extract-msg library not found. Please install it with:")
    print("pip install extract-msg")
    sys.exit(1)


class DocxEmbeddedExtractor:
    def __init__(self, output_dir: str = "extracted_files"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.file_counter = 1
        self.processed_files: Set[str] = set()
        
    def get_file_extension(self, file_data: bytes) -> str:
        """Detect file extension based on file signature/magic bytes"""
        # Common file signatures
        signatures = {
            b'\x50\x4B\x03\x04': '.docx',  # DOCX/ZIP
            b'\xD0\xCF\x11\xE0': '.msg',   # MSG/OLE (Outlook message files)
            b'\xFF\xD8\xFF': '.jpg',        # JPEG
            b'\x89\x50\x4E\x47': '.png',    # PNG
            b'\x47\x49\x46\x38': '.gif',    # GIF
            b'\x25\x50\x44\x46': '.pdf',    # PDF
        }
        
        # Check for OLE Compound Document (could be .doc or .msg)
        if file_data.startswith(b'\xD0\xCF\x11\xE0'):
            # Try to determine if it's MSG by looking for MSG-specific signatures
            if b'Microsoft Office Outlook' in file_data[:1000] or b'__substg1.0_' in file_data[:2000]:
                return '.msg'
            else:
                return '.doc'
        
        for signature, ext in signatures.items():
            if file_data.startswith(signature):
                return ext
        return '.bin'  # Unknown binary file
    
    def extract_msg_attachments(self, msg_path: str, level: int = 0) -> List[str]:
        """Extract attachments from a .msg (Outlook email) file"""
        msg_path = Path(msg_path)
        
        print(f"{'  ' * level}Processing MSG file: {msg_path.name}")
        
        extracted_files = []
        
        try:
            # Open the MSG file using extract_msg
            msg = extract_msg.Message(str(msg_path))
            
            # Get attachments
            attachments = msg.attachments
            
            if not attachments:
                print(f"{'  ' * level}No attachments found in {msg_path.name}")
                return []
            
            print(f"{'  ' * level}Found {len(attachments)} attachment(s)")
            
            for attachment in attachments:
                try:
                    # Get attachment data and name
                    attachment_data = attachment.data
                    original_name = attachment.longFilename or attachment.shortFilename
                    
                    if not attachment_data:
                        print(f"{'  ' * level}Skipping empty attachment: {original_name}")
                        continue
                    
                    # Determine file extension
                    if original_name:
                        # Use original extension if available
                        _, ext = os.path.splitext(original_name)
                        if not ext:
                            ext = self.get_file_extension(attachment_data)
                    else:
                        ext = self.get_file_extension(attachment_data)
                        original_name = f"attachment_{self.file_counter}"
                    
                    # Create output filename
                    output_filename = f"extracted_file_{self.file_counter:03d}{ext}"
                    output_path = self.output_dir / output_filename
                    
                    # Write the extracted attachment
                    with open(output_path, 'wb') as f:
                        f.write(attachment_data)
                    
                    print(f"{'  ' * level}Extracted attachment: {output_filename} (original: {original_name})")
                    extracted_files.append(str(output_path))
                    self.file_counter += 1
                    
                    # Recursively process if it's a supported file type
                    if ext.lower() == '.docx':
                        print(f"{'  ' * level}Found nested DOCX in attachment, recursing...")
                        nested_files = self.extract_embedded_files(output_path, level + 1)
                        extracted_files.extend(nested_files)
                    elif ext.lower() == '.msg':
                        print(f"{'  ' * level}Found nested MSG in attachment, recursing...")
                        nested_files = self.extract_msg_attachments(output_path, level + 1)
                        extracted_files.extend(nested_files)
                
                except Exception as e:
                    print(f"{'  ' * level}Error extracting attachment: {str(e)}")
                    continue
            
            # Close the MSG file
            msg.close()
        
        except Exception as e:
            print(f"{'  ' * level}Error processing MSG file {msg_path.name}: {str(e)}")
        
        return extracted_files
        """Extract embedded files from a DOCX file"""
        docx_path = Path(docx_path)
        
        # Avoid infinite recursion by tracking processed files
        abs_path = str(docx_path.absolute())
        if abs_path in self.processed_files:
            print(f"{'  ' * level}Skipping already processed file: {docx_path.name}")
            return []
        
        self.processed_files.add(abs_path)
        
        print(f"{'  ' * level}Processing: {docx_path.name}")
        
        if not docx_path.exists():
            print(f"{'  ' * level}Error: File not found - {docx_path}")
            return []
        
        extracted_files = []
        
        try:
            # Open DOCX as ZIP file to access embedded objects
            with zipfile.ZipFile(docx_path, 'r') as zip_file:
                # Look for embedded objects in the embeddings folder
                embedding_files = [f for f in zip_file.namelist() 
                                 if f.startswith('word/embeddings/')]
                
                if not embedding_files:
                    print(f"{'  ' * level}No embedded files found in {docx_path.name}")
                    return []
                
                print(f"{'  ' * level}Found {len(embedding_files)} embedded file(s)")
                
                for embed_file in embedding_files:
                    try:
                        # Extract the embedded file data
                        file_data = zip_file.read(embed_file)
                        
                        # Determine file extension
                        file_ext = self.get_file_extension(file_data)
                        
                        # Create output filename
                        output_filename = f"extracted_file_{self.file_counter:03d}{file_ext}"
                        output_path = self.output_dir / output_filename
                        
                        # Write the extracted file
                        with open(output_path, 'wb') as f:
                            f.write(file_data)
                        
                        print(f"{'  ' * level}Extracted: {output_filename}")
                        extracted_files.append(str(output_path))
                        self.file_counter += 1
                        
                        # If the extracted file is a DOCX, recursively process it
                        if file_ext == '.docx':
                            print(f"{'  ' * level}Found nested DOCX, recursing...")
                            nested_files = self.extract_embedded_files(output_path, level + 1)
                            extracted_files.extend(nested_files)
                        # If the extracted file is a MSG, recursively process it
                        elif file_ext == '.msg':
                            print(f"{'  ' * level}Found nested MSG, recursing...")
                            nested_files = self.extract_msg_attachments(output_path, level + 1)
                            extracted_files.extend(nested_files)
                    
                    except Exception as e:
                        print(f"{'  ' * level}Error extracting {embed_file}: {str(e)}")
                        continue
        
        except zipfile.BadZipFile:
            print(f"{'  ' * level}Error: {docx_path.name} is not a valid DOCX file")
        except Exception as e:
            print(f"{'  ' * level}Error processing {docx_path.name}: {str(e)}")
        
        return extracted_files
    
    def process_document(self, input_file: str) -> List[str]:
        """Main method to process a DOCX document and extract all embedded files"""
        print(f"Starting extraction from: {input_file}")
        print(f"Output directory: {self.output_dir.absolute()}")
        print("-" * 50)
        
        # Determine file type and process accordingly
        input_path = Path(input_file)
        if input_path.suffix.lower() == '.msg':
            extracted_files = self.extract_msg_attachments(input_file)
        else:
            extracted_files = self.extract_embedded_files(input_file)
        
        print("-" * 50)
        print(f"Extraction complete. Total files extracted: {len(extracted_files)}")
        
        if extracted_files:
            print("Extracted files:")
            for file_path in extracted_files:
                print(f"  {file_path}")
        
        return extracted_files


def main():
    parser = argparse.ArgumentParser(description='Extract embedded files from DOCX documents and MSG email files')
    parser.add_argument('input_file', help='Input DOCX or MSG file path')
    parser.add_argument('-o', '--output', default='extracted_files', 
                       help='Output directory (default: extracted_files)')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.input_file):
        print(f"Error: Input file '{args.input_file}' not found")
        sys.exit(1)
    
    input_ext = Path(args.input_file).suffix.lower()
    if input_ext not in ['.docx', '.msg']:
        print(f"Warning: Input file doesn't have .docx or .msg extension (found: {input_ext})")
    
    # Create extractor and process the document
    extractor = DocxEmbeddedExtractor(args.output)
    extracted_files = extractor.process_document(args.input_file)
    
    if not extracted_files:
        print("No embedded files or attachments found or extracted.")
        sys.exit(1)


if __name__ == "__main__":
    main()
