import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from dataclasses import dataclass
from typing import List, Tuple, Dict
import time
from collections import defaultdict
from multiprocessing import Pool, cpu_count, current_process, Manager, Lock
import os
import datetime


# --- 1. Data Structures ---

@dataclass
class Fragment:
    """Represents a spherical fragment (protostar)"""
    x: float
    y: float
    z: float
    radius: float
    mass: float


# --- 2. Simulation Class (with shared Lock and logging implementation) ---

class IMFSimulation:
    """
    Simulates the Initial Mass Function using domain packing principles.
    Optimized with 3D Grid and Multiprocessing for concurrent execution.
    """

    BIN_SIZE: float = 0.45

    def __init__(self, r_min: float = 0.027, r_max: float = 0.21,
                 master_radius: float = 1.0, lock: Lock = None,
                 status_file_path: str = None):

        self.r_min = r_min
        self.r_max = r_max
        self.master_radius = master_radius
        self.master_volume = 1.0

        # Internal state for a single run
        self._fragments_grid: Dict[Tuple[int, int, int], List[Fragment]] = defaultdict(list)
        self._fragments_list: List[Fragment] = []

        # --- Telemetry Attributes ---
        self.lock = lock
        self.status_file_path = status_file_path
        self.ff_target = 0.0
        self.run_start_time = 0.0

    def _get_bin_coords(self, x: float, y: float, z: float) -> Tuple[int, int, int]:
        """Maps a position (x, y, z) to integer grid coordinates."""
        x_shifted = x + self.master_radius
        y_shifted = y + self.master_radius
        z_shifted = z + self.master_radius

        i = int(x_shifted / self.BIN_SIZE)
        j = int(y_shifted / self.BIN_SIZE)
        k = int(z_shifted / self.BIN_SIZE)
        return i, j, k

    def random_position_in_sphere(self) -> Tuple[float, float, float]:
        """Generate random position inside master sphere using rejection sampling."""
        while True:
            x = np.random.uniform(-self.master_radius, self.master_radius)
            y = np.random.uniform(-self.master_radius, self.master_radius)
            z = np.random.uniform(-self.master_radius, self.master_radius)

            if x ** 2 + y ** 2 + z ** 2 <= self.master_radius ** 2:
                return x, y, z

    def distance_to_boundary(self, x: float, y: float, z: float) -> float:
        """Calculate distance from point to master sphere boundary."""
        r = np.sqrt(x ** 2 + y ** 2 + z ** 2)
        return self.master_radius - r

    def distance_between_points(self, x1: float, y1: float, z1: float,
                                x2: float, y2: float, z2: float) -> float:
        """Calculate Euclidean distance between two points."""
        return np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2)

    def calculate_available_radius(self, x: float, y: float, z: float) -> float:
        """
        Calculate maximum radius available at position (x,y,z) without overlapping,
        using the 3D grid for acceleration.
        """
        r_available = self.distance_to_boundary(x, y, z)
        r_available = min(r_available, self.r_max)

        i, j, k = self._get_bin_coords(x, y, z)

        # Check the 27 relevant bins
        for di in [-1, 0, 1]:
            for dj in [-1, 0, 1]:
                for dk in [-1, 0, 1]:
                    neighbor_bin = (i + di, j + dj, k + dk)

                    for frag in self._fragments_grid[neighbor_bin]:
                        d = self.distance_between_points(x, y, z, frag.x, frag.y, frag.z)
                        available_near_frag = d - frag.radius
                        r_available = min(r_available, available_near_frag)

                        if r_available < self.r_min:
                            return 0.0

        return max(0.0, r_available)

    def _log_status(self, current_filling_factor: float, num_fragments: int, consecutive_failures: int,
                    is_final: bool = False):
        """Writes telemetry data to the status file using the shared Lock."""
        if not self.lock or not self.status_file_path:
            return

        elapsed_time = time.time() - self.run_start_time
        proc_name = current_process().name

        # Only log periodically or when a completion/failure threshold is met
        if not is_final and consecutive_failures < 5000 and elapsed_time % 30.0 < 1.0:
            return

        log_entry = (
            f"{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | "
            f"PROC: {proc_name:<10} | "
            f"FF_TGT: {self.ff_target:.2f} | "
            f"ELAPSED: {elapsed_time:8.1f}s | "
            f"FF_CURR: {current_filling_factor:.4f} | "
            f"FRAGMENTS: {num_fragments:<6} | "
            f"FAILURES: {consecutive_failures:<6}\n"
        )

        try:
            with self.lock:
                with open(self.status_file_path, 'a') as f:
                    f.write(log_entry)
        except Exception as e:
            print(f"[{proc_name}] ERROR writing status file: {e}")

    def run_single_simulation(self, target_filling_factor: float,
                              max_attempts: int = 200000,
                              radius_distribution: str = 'uniform') -> List[Fragment]:
        """
        Run a single simulation filling the master volume.
        """
        self.ff_target = target_filling_factor
        self.run_start_time = time.time()

        self._fragments_grid.clear()
        self._fragments_list.clear()

        current_filling_factor = 0.0
        consecutive_failures = 0

        proc_name = current_process().name
        print(f"[{proc_name}] Starting FF={target_filling_factor:.2f} run.")

        log_interval_time = 30.0
        last_log_time = time.time()

        while current_filling_factor < target_filling_factor:

            x, y, z = self.random_position_in_sphere()
            r_available = self.calculate_available_radius(x, y, z)

            if r_available < self.r_min:
                consecutive_failures += 1
                if consecutive_failures > max_attempts:
                    print(f"[{proc_name}] Reached max attempts. Stopping at FF={current_filling_factor:.4f}")
                    break

                if consecutive_failures % 5000 == 0 or time.time() - last_log_time > log_interval_time:
                    self._log_status(current_filling_factor, len(self._fragments_list), consecutive_failures)
                    last_log_time = time.time()

                continue

            # SUCCESS: Fragment placed
            consecutive_failures = 0

            # Select radius
            if radius_distribution == 'uniform':
                radius = np.random.uniform(self.r_min, r_available)
            else:
                log_r_min = np.log10(self.r_min)
                log_r_available = np.log10(max(r_available, self.r_min * 1.000001))
                radius = 10 ** np.random.uniform(log_r_min, log_r_available)

            radius = np.clip(radius, self.r_min, r_available)
            mass = radius ** 3

            fragment = Fragment(x, y, z, radius, mass)
            self._fragments_list.append(fragment)

            bin_coords = self._get_bin_coords(x, y, z)
            self._fragments_grid[bin_coords].append(fragment)

            current_filling_factor += mass

            if time.time() - last_log_time > log_interval_time:
                self._log_status(current_filling_factor, len(self._fragments_list), 0)
                last_log_time = time.time()

        self._log_status(current_filling_factor, len(self._fragments_list), consecutive_failures, is_final=True)

        print(f"[{proc_name}] Completed FF={target_filling_factor:.2f} with {len(self._fragments_list)} fragments.")

        return np.array([f.mass for f in self._fragments_list], dtype=np.float32)

    @staticmethod
    def _run_single_simulation_wrapper(target_filling_factor: float, run_id: int,
                                       r_min: float, r_max: float, lock: Lock,
                                       status_file_path: str) -> Tuple[float, np.ndarray]:
        """
        Wrapper function for multiprocessing. Receives the shared lock and file path.
        """
        np.random.seed(os.getpid() + run_id)

        sim_instance = IMFSimulation(r_min=r_min, r_max=r_max, lock=lock, status_file_path=status_file_path)

        masses = sim_instance.run_single_simulation(target_filling_factor)
        return target_filling_factor, masses

    @staticmethod
    def calculate_mass_function_slope(masses: np.ndarray,
                                      mass_min: float, mass_max: float) -> Tuple[float, float]:
        """Calculate power law exponent (alpha) for mass function."""
        mask = (masses >= mass_min) & (masses <= mass_max)
        masses_in_range = masses[mask]

        if len(masses_in_range) < 10:
            return np.nan, np.nan

        n_bins = 20
        log_bins = np.logspace(np.log10(mass_min), np.log10(mass_max), n_bins + 1)
        counts, bin_edges = np.histogram(masses_in_range, bins=log_bins)
        bin_centers = np.sqrt(bin_edges[1:] * bin_edges[:-1])
        bin_widths = bin_edges[1:] - bin_edges[:-1]

        dN_dm = counts / bin_widths

        nonzero = dN_dm > 0
        if np.sum(nonzero) < 3:
            return np.nan, np.nan

        log_mass = np.log10(bin_centers[nonzero])
        log_dN_dm = np.log10(dN_dm[nonzero])

        slope, std_err = stats.linregress(log_mass, log_dN_dm)[:2]
        return slope, std_err


# --- 3. Output Generation Functions (Plotting and TXT) ---

# MODIFIED: Removed the 'regime' argument from the function signature as we will plot all regimes internally
def plot_alpha_vs_filling_factor(results_list: List[dict], ax: plt.Axes):
    """
    Plots the mean alpha slope against the filling factor (FF) for ALL mass regimes
    EXCEPT 'brown_dwarf' on the same axes.
    """

    # Define plot settings for each regime
    plot_settings = {
        'high': ('High Mass', 'C0', 'o'),
        'intermediate': ('Intermediate Mass', 'C1', 's'),
        'low': ('Low Mass', 'C2', '^'),
        'brown_dwarf': ('Brown Dwarf', 'C3', 'x')  # Retain for reference but exclude below
    }

    # Iterate through all regimes to plot
    for regime, (label_text, color, marker) in plot_settings.items():
        # --- EXCLUSION CONDITION ADDED HERE ---
        if regime == 'brown_dwarf':
            continue
        # --------------------------------------

        ffs = []
        mean_alphas = []
        std_alphas = []

        for r in results_list:
            ff = r['filling_factor']
            # Safely get data for the current regime
            data = r['alphas'].get(regime, {})

            mean_alpha = data.get('mean')
            std_alpha = data.get('std')

            if not np.isnan(mean_alpha):
                ffs.append(ff)
                mean_alphas.append(mean_alpha)
                # Ensure std_alpha is not NaN before appending
                std_alphas.append(std_alpha if not np.isnan(std_alpha) else 0.0)

        # Plot the error bars for this regime
        ax.errorbar(ffs, mean_alphas, yerr=std_alphas,
                    fmt=f'{marker}-', capsize=5,
                    color=color, label=label_text, zorder=3)

    # Add the Salpeter reference line (typically -2.35 for dN/dm ~ m^alpha)
    ax.axhline(-2.35, color='k', linestyle='--', alpha=0.7, label='Salpeter $\\alpha=-2.35$', zorder=1)

    ax.set_xlabel('Filling Factor (FF)')
    ax.set_ylabel('Power-law Slope ($\mathbf{\\alpha}$) [log(dN/dm) $\propto$ $\\alpha$ log(m)]')
    ax.set_title('IMF Slope vs. Filling Factor (Excluding Brown Dwarfs)')
    ax.legend(title='Mass Regime', loc='lower left')
    ax.grid(True, which='both', linestyle=':', alpha=0.6)


def plot_mass_distribution(results: dict, ax: plt.Axes):
    """Plots the log-log mass distribution (dN/dm vs m) for a specific FF."""

    ff = results['filling_factor']
    all_masses = np.concatenate(results['all_masses'])

    # Determine plot limits based on the defined mass ranges
    m_min_overall = results['mass_ranges']['brown_dwarf'][0]
    m_max_overall = results['mass_ranges']['high'][1]

    # Use a wide range of bins for a smooth log-log plot
    # The true minimum mass is R_MIN^3 ~ 1.97e-5
    min_log_val = np.log10(m_min_overall * 0.5)
    max_log_val = np.log10(m_max_overall)
    log_bins = np.logspace(min_log_val, max_log_val, 50)

    counts, bin_edges = np.histogram(all_masses, bins=log_bins)

    bin_widths = bin_edges[1:] - bin_edges[:-1]
    bin_centers = np.sqrt(bin_edges[1:] * bin_edges[:-1])
    dN_dm = counts / bin_widths

    nonzero = dN_dm > 0
    ax.loglog(bin_centers[nonzero], dN_dm[nonzero], 'o', markersize=4, label=f"FF={ff:.2f} Data")

    ax.set_xlabel('Normalized Mass (m)')
    ax.set_ylabel('dN/dm')
    ax.set_title(f'Mass Function for FF={ff:.2f}')
    ax.grid(True, which='both', linestyle=':', alpha=0.6)
    ax.legend()


def generate_results_file(results_list: List[dict], total_time: float, save_path: str = 'imf_simulation_results.txt'):
    """Creates a text file summary of the simulation results."""

    with open(save_path, 'w') as f:
        f.write("=" * 80 + "\n")
        f.write("INITIAL MASS FUNCTION SIMULATION RESULTS\n")
        f.write("Accelerated with 3D Grid and Multiprocessing\n")
        f.write(f"Total Wall Clock Time: {total_time:.2f} seconds\n")
        f.write("=" * 80 + "\n\n")

        f.write("Power Law Exponent (alpha) Summary: dN/dm ~ m^alpha\n")
        f.write("-" * 80 + "\n")

        # Header for the table
        f.write(
            f"{'FF':<5} | {'Runs':<5} | {'Regime':<15} | {'Mass Range (Norm)':<20} | {'Alpha (Mean)':<15} | {'Std Dev':<10}\n")
        f.write("-" * 80 + "\n")

        for results in results_list:
            ff = results['filling_factor']
            n_runs = results['n_runs']
            mass_ranges = results['mass_ranges']

            ff_header_printed = False

            for regime in ['high', 'intermediate', 'low', 'brown_dwarf']:
                # FIX: Use .get() to safely retrieve data, preventing KeyError
                data = results['alphas'].get(regime, {'mean': np.nan, 'std': np.nan})
                m_min, m_max = mass_ranges[regime]

                mass_range_str = f"({m_min:.1e}-{m_max:.1e})"

                mean_alpha_str = f"{data['mean']:6.3f}" if not np.isnan(data['mean']) else "N/A"
                std_dev_str = f"{data['std']:6.3f}" if not np.isnan(data['std']) else "N/A"

                ff_str = f"{ff:<5}" if not ff_header_printed else f"{'':<5}"
                runs_str = f"{n_runs:<5}" if not ff_header_printed else f"{'':<5}"

                f.write(
                    f"{ff_str} | {runs_str} | {regime:<15} | {mass_range_str:<20} | {mean_alpha_str:<15} | {std_dev_str:<10}\n")

                ff_header_printed = True
            f.write("-" * 80 + "\n")

    print(f"Results summary saved to: {save_path}")


# --- 4. Main Execution Logic (Multiprocessing Manager) ---

def main():
    """
    Main execution: Run all simulations concurrently using multiprocessing,
    managing the shared lock and initiating all output.
    """
    R_MIN = 0.027  # Lower limit of allowed stellar masses (0.1 M_sun equivalent)
    R_MAX = 0.21

    MIN_NORMALIZED_MASS = R_MIN ** 3

    max_cores = cpu_count()
    # Note: Setting a realistic max number of processes is crucial for system stability.
    # The original value of 'min(88, max_cores)' is kept, assuming a powerful environment.
    num_processes = min(88, max_cores)

    # Define run configuration
    ff_configs = {
        0.2: 5, 0.3: 5, 0.4: 5,
        0.48: 0,  # Increased to ensure sufficient data for plotting mass distribution
        0.6: 0,
        0.7: 0
    }

    STATUS_FILE = 'status.txt'
    if os.path.exists(STATUS_FILE):
        os.remove(STATUS_FILE)

    manager = Manager()
    sim_lock = manager.Lock()

    tasks = []
    run_id_counter = 0
    for ff, n_runs in ff_configs.items():
        for _ in range(n_runs):
            tasks.append((ff, run_id_counter, R_MIN, R_MAX))
            run_id_counter += 1

    # Ensure a single FF is chosen for the second plot, using ff_fig2=0.48 as a default
    ff_fig2 = 0.40

    print("=" * 70)
    print("IMF DOMAIN PACKING SIMULATION (MULTIPROCESSING)")
    print(f"Using {num_processes} concurrent processes. Total runs: {len(tasks)}")
    print(f"Progress will be logged in: {STATUS_FILE}")
    print("=" * 70)

    start_time = time.time()

    pool_tasks = [
        (ff, run_id, R_MIN, R_MAX, sim_lock, STATUS_FILE)
        for ff, run_id, R_MIN, R_MAX in tasks
    ]

    with Pool(processes=num_processes) as pool:
        all_results = pool.starmap(IMFSimulation._run_single_simulation_wrapper, pool_tasks)

    end_time_sim = time.time()
    total_sim_time = end_time_sim - start_time

    # ----------------------------------------------------
    # --- Post-Processing and Output ---
    # ----------------------------------------------------

    masses_by_ff: Dict[float, List[np.ndarray]] = defaultdict(list)
    for ff, masses in all_results:
        masses_by_ff[ff].append(masses)

    results_list = []

    # Mass ranges for analysis (normalized units: M ~ R^3)
    mass_ranges = {
        'high': (0.0008, 0.008),
        'intermediate': (0.00016, 0.0016),
        'low': (0.00002, 0.0002),
        'brown_dwarf': (MIN_NORMALIZED_MASS, 0.00002)
    }

    # Analyze and compile results
    for ff in sorted(masses_by_ff.keys()):
        all_masses_ff = masses_by_ff[ff]
        alphas_data = defaultdict(list)

        for masses in all_masses_ff:
            for regime, (m_min, m_max) in mass_ranges.items():
                alpha, _ = IMFSimulation.calculate_mass_function_slope(masses, m_min, m_max)
                if not np.isnan(alpha):
                    alphas_data[regime].append(alpha)

        ff_results = {
            'filling_factor': ff, 'n_runs': len(all_masses_ff),
            'all_masses': all_masses_ff, 'mass_ranges': mass_ranges,
            'alphas': {
                regime: {
                    'values': alphas, 'mean': np.mean(alphas) if alphas else np.nan,
                    'std': np.std(alphas) if alphas else np.nan
                } for regime, alphas in alphas_data.items()
            }
        }
        results_list.append(ff_results)

    # --- PLOTTING FIX: Generate both plots and save them to one file (plots.png) ---

    # 1. Create a figure with two subplots (1 row, 2 columns)
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

    # 2. Plot Alpha vs FF (on ax1) - The function now excludes 'brown_dwarf'
    plot_alpha_vs_filling_factor(results_list, ax1)

    # 3. Plot Mass Distribution (on ax2) - Plot the result for the specific ff_fig2
    results_fig2 = [r for r in results_list if r['filling_factor'] == ff_fig2]
    if results_fig2:
        plot_mass_distribution(results_fig2[0], ax2)
    else:
        # Handle case where ff_fig2 wasn't run or has no data
        ax2.set_title(f"Mass Function: Data for FF={ff_fig2:.2f} Not Found")


    # 4. Save the combined figure
    plt.tight_layout()
    plot_save_path = 'plots.png'
    plt.savefig(plot_save_path)
    plt.close(fig)

    print(f"\nPlots saved to: {plot_save_path}")
    # --- END PLOTTING FIX ---

    # Generate text summary file
    generate_results_file(results_list, total_sim_time)

    print("\n" + "=" * 70)
    print(f"ALL OUTPUT GENERATED. Total time: {time.time() - start_time:.2f} seconds.")
    print("=" * 70)


if __name__ == "__main__":
    main()
